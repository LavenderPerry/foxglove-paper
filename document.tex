\documentclass[10pt,twocolumn]{article}

% use the oxycomps style file
\usepackage{oxycomps}

% usage: \fixme[comments describing issue]{text to be fixed}
% define \fixme as not doing anything special
\newcommand{\fixme}[2][]{#2}
% overwrite it so it shows up as red
\renewcommand{\fixme}[2][]{\textcolor{red}{#2}}
% overwrite it again so related text shows as footnotes
%\renewcommand{\fixme}[2][]{\textcolor{red}{#2\footnote{#1}}}

% read references.bib for the bibtex data
\bibliography{references}

% include metadata in the generated pdf file
\pdfinfo{
    /Title (Foxglove Video Game Launcher)
    /Author (Lavender Perry)
}

% set the title and author information
\title{Foxglove Video Game Console}
\author{Lavender Perry}
\affiliation{Occidental College}
\email{lperry@oxy.edu}

\begin{document}

\maketitle

% TODO: finish the paper and remove the following line
I will finish this paper soon...

\section{Introduction and Problem Context}

The video game launcher is one of the most important, yet most overlooked,
aspects of the video gaming experience. Game launchers typically handle
listing, managing, and -- of course -- launching games.
Often times, to make the process of installing games for the launcher easier,
it will integrate with a game distribution platform. This allows users of the
launcher to find new games and interact with a broader ecosystem. The type of
games available for the launcher are in this case shaped by the distribution
platform, not just in technicalities such as which games are uploaded there,
but the artistic culture it fosters through its design decisions
\cite{werning_itchio_2019}.
However, it is often the case that the launcher facilitates interacting with the
distribution platform, rather than the distribution platform facilitating
interaction with the launcher.

More than just the video games themselves, video game launchers can manage mods
for games. A mod changes aspects of a game, which can include mechanics,
artwork, or anything else. Most launchers that manage mods do so for one
specific game, rather than multiple. The ones that do manage mods for multiple
games rely on the game developers to add support for modding, or multiple
different methods to mod each game, meaning a modder has to learn multiple
APIs, one for each game they want to mod. This increases the barrier to entry
significantly, and limits the amount of games that can be experimented with.

There are many reasons why improving the game modding experience is a worthwhile
pursuit. Video game modding allows individuals to express themselves and
learn about computers while engaging with media they enjoy
\cite{kacmarcik_introducing_2009}. Additionally, blurring the lines between
consumer and creator of anything, including video games, is a process used by
many marginalized people in order to access and
change systems that exclude them \cite{hamraie_crip_2019}. Modding and remixing
are
important tools for self expression and protest, particularly for
people underrepresented in computer science, gaming, and
mainstream technology design. More specifically to video games, the game modding
scene in Brazil has been studied to reflect a more decolonial, anti-capitalist
ideal of media interaction \cite{messias_emergent_2020}.

My project is Foxglove, a video game launcher that aims to provide a
general-purpose way to mod a wide variety of games. It also tries to interact
with game distribution platforms without becoming strictly tied to them. This
allows users to benefit from the creativity and culture of these websites
without tying them to the whims of the platform or the internet in general.

\section{Technical Background}

These are the technical terms and concepts that are relevant to my project.

\subsection{Modding}

Modding, short for modifying, is taking a game or software and changing it.
Typically, this is done to add features or present a different ideal of how the
software should function, often in a way that serves the user and that the
original creator of the software did not anticipate. A large amount of my
project revolves around the idea of modding, and the rest of the terms in this
technical background are all related to it in some way.

\subsection{Code Injection}

Code injection is the process of making a software load and run third party
code. One of the most common uses is internet-based malicious attacks
where untrusted input is improperly handled
\cite{ray_defining_2012}, but that is not the only use.
Injecting code is typically how modding is accomplished, and therefore
allows many of the practices discussed in this project to occur. Sometimes this
is accomplished by exploitable bugs in the software itself, while other times,
and in my project, it is accomplished by manipulating the environment in which
the software runs.

\subsection{Patches}

A patch describes how source code changes from one state to the next. Patches
function as instructions for how to apply source code changes, and are
especially useful for modding. Often, a modding API allowing users to inject
their code into software will take patches as input to specify what code should
be injected. Foxglove's modding API uses patches as well.

\section{Prior Work}

There are multiple studies as well as other projects that are relevant to
Foxglove, which I discuss and categorize here.

\subsection{Development and Modding Platforms}

LÖVE is a framework for making video games \cite{noauthor_love_nodate}
that my project is both built upon and targets. The game with the biggest
(and arguably only) modding scene built on LÖVE is Balatro
\cite{noauthor_balatro_2025}. Because of the popularity of Balatro, multiple
methods of modding LÖVE games have been created. However, there is only one
aside from this project that is not exclusive to Balatro.
Lovely is a library that, when loaded alongside LÖVE,
allows for Lua code injection into a
LÖVE game. 
Although primarily used to mod Balatro, it should work for any other game made
with the LÖVE framework.
It uses its own format for making patches to games which directly
inspired the patch format of this project
\cite{green_ethangreen-devlovely-injector_2025}.
Both Lovely and Foxglove allow for
lines of code to be inserted before, after, or replacing other specified lines.
Lovely is a great method to mod LÖVE games, but there are a few reasons I wrote
my own instead of interfacing with it. The main issue is that Lovely does not
easily let you specify mods for specific games. Any game launched with Lovely
will use the same mods as every other game. This is fine if all you want to do
is mod Balatro (the use case Lovely was likely made for), but for my project
which emphasizes a general purpose approach to modding any game it supports,
the inability to specify what game a mod is for becomes a major problem.

\subsection{Launchers}

Likely the most well-known launcher that provides the most similar features to
Foxglove is the Steam launcher. Of particular note is the Steam Workshop,
where users can share mods for games \cite{noauthor_steam_nodate}.
Steam is similar to Foxglove in the way
that both provide facilities for modding. However, the social features of Steam
are out of scope for Foxglove, which favors using existing social
networks to share games and mods over creating a new one. Steam also fits into
both the criticisms of existing launchers elaborated on in the introduction,
of requiring game developers to add modding support to their games to make
modding work, as well as being tied to a specific game distribution platform.

The Itch.io launcher is similar to Steam in design, but the differences cause
Itch.io to foster what is commonly percieved as the complete opposite culture
of Steam. One notable difference is the inclusion of information on what tool
a game is made in. This both encourages a culture where the player of games
is educated on the game development process \cite{werning_itchio_2019}
(which is a good culture for modding to occur),
and also makes it easier for Foxglove to pull from Itch.io,
because I can filter for games that work with the launcher (made in LÖVE).

My project is not the first launcher made for LÖVE games.
Another one, called Love Launcher, uses the framework to create a menu for
running LÖVE games \cite{noauthor_glitchapplovelauncher_nodate}. Foxglove
also uses LÖVE to display its UI, but no other aspects of technical
implementation nor design are similar, as my launcher has significantly
different goals.

\section{Methods}

\subsection{User Interface}

The user interface (UI) provides graphical utilities to browse and run games,
install games and mods, and find new games online. I started with a prototype in
Figma, to solidify the design before technical implementation.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.95\linewidth]{figma.png}
    \caption{
        The original prototype for the game selection screen.
    }
\end{figure}

From this prototype, I got the foundational vision for the UI. I kept the
black and white, high contrast UI, reminiscent of the Playdate handheld game
console menu \cite{inc_inside_nodate}, as well as the flow of scrolling through
games, inspired by the Nintendo Switch home screen
\cite{noauthor_nintendo_nodate}. These sources of inspiration,
as well as the design being planned around the constraints of a smaller screen,
reflect the original vision for this
launcher as being one component of a handheld game console. Although I did not
end up pursuing making the entire handheld, I kept these aspects of the design
to facilitate more work towards a physical handheld device running my launcher
in the future. The color choices also make the UI look vaguely cyberpunk,
an aesthetic that commonly explores themes of revolutionary
hacking and modding \cite{csicsery-ronay_cyberpunk_1988}. Although the
resemblance was not intentional, I consider it appropriate for the type of
project I am making, as well as adding a unique flair lacking from many other
modern user interface designs.

I do make significant changes to this screen, though. Instead of a pixelated
flower serving as the indicator of a game being selected, a neon pink border
is drawn around the selected game. This clears up ambiguities by using more
recognizable visual language, at the cost of the design losing a slight amount
of personality. I consider this trade off worth it because it makes the launcher
easier to understand and use. Early user feedback from my peers informs this
decision. Other aspects of the software can be more fun and show more
personality without sacrificing ease of understanding.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.95\linewidth]{gamemenu.png}
    \caption{
        A screenshot of the menu for selecting games in the final product.
    }
\end{figure}

The other change is the settings icon being replaced with an 'online' icon.
This is not for any aesthetic reasons, but rather a consequence of my priorities
changing as the project progressed. Instead of a settings screen, the icon opens
up the screen that shows games from online. I decided to prioritize getting that
feature working before adding customization options because it is a core feature
satisfying one of the goals laid out for the project, rather than an auxiliary
feature that is more generic to other software, as a settings menu would be.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.95\linewidth]{onlinemenu.png}
    \caption{
        A screenshot of the menu for browsing online games in the final product.
    }
\end{figure}

The online screen is much simpler and less polished than the game selection
screen. Despite that, it still required a few decisions in its design process.
The first was whether or not to include images on the screen, as is done on the
game selection menu. Although it would make the menu look better, I ultimately
decided not to do so, as the images would need to be downloaded from the
internet, which does not scale well performance wise for large amounts of games.

\subsection{Modding API}

The modding API uses a patch-based format 
to allow for direct
source code modification of games.
The user is
able to specify code to inject into the source of a game. This allows for large
amounts of flexibility in modding games, as third party code may modify anything
the user would like, including implementing an entirely different game on top of
an existing one.

Another type of modding API I could have chosen to implement is a system built
around
callback functions. As my current game launcher already has access to the
process in which the game is running, it can call other functions before or
after calling specific functions the running game defined. By calling functions
defined by a mod in specific situations, I can implement a callback-based
modding API.

One advantage of a callback-based modding API over direct source code
modification through patches is that the user does not have to reference the
game's source code as much. Instead of thinking about their changes based on
what position in the original source code they will take place at, the user can
think about their changes based on what situation they will be executed at. This
may facilitate modding better, especially for users unfamiliar with reading
source code. A callback-based system may also be easier for users because there
is no patch format to learn. Instead, callbacks are specified simply by defining
functions, so there is nothing extra to learn in addition to the coding skills
necessary to mod games already. Another advantage to a callback-based system is
it decreases the chance of issues when applying multiple mods to the same game.
If multiple people make a mod for the same game, their source code may overwrite
each other in a patch-based system. In a callback-based system, it is easier to
ensure compatability between mods, as all mod functions are called separately
from each other and can not overwrite each other.

However, a patch-based system has many advantages over a callback-based system.
First, it is much more flexible. While a callback-based system limits modders to
injecting their code only where I have created a callback, a patch-based system
allows modders to inject their code anywhere. Additionally, a callback-based
system may be created on top of a patch-based system, but a patch-based system
can not be created on top of a callback-based system. Another reason to prefer a
patch-based system is I can use a system inspired by Lovely for part of it
instead of needing to
design the entire thing from scratch. This also partially mitigates the
disadvantage of needing to learn a patch format, because users may already know
Lovely's format,
or may choose to use their knowledge of the format for modding
outside the context of Foxglove.

\subsection{Launching Games}

To launch games, the launcher uses my own fork of LÖVE. LÖVE already allows
games to restart themselves, as well as letting them pass a value to themselves
to be used after they restart. By modifying LÖVE to parse this restart value
and launch a different game depending on what the value specifies, I can add the
ability for games to launch other games.

\section{Evaluation Metrics}

Evaluation shows that the
launcher meets goals of functionality
(being able to run games), aesthetics (looking pretty),
and ease of use (users can use the
launcher without guidance).

\subsection{Testing With Games}

To ensure the launcher can handle a reasonable variety of games, I tested
multiple games made with the LÖVE framework.
Games could all be listed in the UI
and launched. Additionally, Balatro could be modded using a mod that I ported
to Foxglove's modding API.

\subsection{User Testing}

Part of the evaluation involved user testing. Testers were able to
navigate the UI with some guidance. The main issue was knowing the control
scheme, as I do not provide a tutorial for that anywhere.
Testers appreciated the aesthetics of the UI as well, but desired more
customization options.

\section{Results and Discussion}

As shown by testing, the game launcher was a successful project.
Some possible next steps include getting the launcher to run on
a wider variety of hardware, as well as improving documentation for controls
and modding APIs.

\subsection{Launching Games}

\section{Ethical Considerations}

The ethics of my project mainly revolve around the fact that I am building
for the world that I wish existed, not the one we currently live in. Although my
project could potentially get more people into art, video games, and computer
science, the issues excluding people from doing those things are at least
partially community and societal, rather than technological.
I explore how making
something easier is not always the solution, consider the role of an
individual's lack of free time in creating an access barrier, and explain the
issues involved in making a hardware-based project such as my own. Despite the
ethical issues arising from my project, I believe it is still worthwhile to
pursue.

\subsection{Difficulty}

One important consideration is if the project will, rather than encouraging
users to mod games, have the opposite effect.
Goode and Cruise argue that a significant motivating factor for people to remove
copy protection from software is the difficulty in doing so, where the
individual removing the copy protection seeks a personal challenge
\cite{goode_what_2006}. With that in mind, it is reasonable to hold the belief
that video game modding is motivated, in part or entirely, by the
difficulty of it. Removal of copy protection is a form of modding, and
motivation by challenge is likely not a quality exclusive to any specific subset
of individuals, so applying it to video game modding is appropriate.
Therefore, making the process of modding video games easier may discourage,
rather than encourage others from doing so.

However, there are other motivations to mod which must be considered.
Brown et al. respond to Goode and Cruise's argument with an alternate view of
why users hack, which emphasizes a difference in interests between the users and
the designers, or the organization dictating what the designers may do
\cite{brown_why_2022}. At first glance, this implies a failure on the designer's
part, yet a better way to view this is through bad design being an individual
judgement that varies from person to person. Therefore, it is possible for users
to still want to modify a game even if it is not maliciously designed.
Even if some users are put off by it being too easy, a significant amount who
were already turned away by it being too difficult will be interested. It should
also be possible for users to scale up the difficulty level depending on what
they make as needed.

\subsection{Time}

Another consideration is under our past and current hegemonic society, time is a
limited, commodified resource. Fellner defines the commodification of time by
defining a set of motivations for how people use their time, which are power,
playfulness, meaning, and belonging. The process of commodifying time involves
increasing the percieved importance of power at the cost of anything else. This
means people often have to devote all their time to capitalist labor and do not
have time to create or enjoy art \cite{fellner_value_2017}. Having time for
things like this launcher is a luxury that is most available to individuals
least impacted by systematic oppression. I'm not exactly sure how to mitigate
these issues, but they're important to think about before implementing features
that require the user to have lots of free time. It may also be another point in
favor of making creating and modding easier, as the more
difficult it is, the more time it will take to learn how to do it.

\subsection{Hardware}

As this project runs on a computer, it requires computer hardware to run.
Mining of materials to use in that
hardware involve inhumane labor practices and exploitation, especially of
communities in the Global South. This extractive, colonial process also
wrecklessly destroys the environment for profit. However, all computer
technologies -- including my project, including any devices for personal or
educational use, and including any devices used to raise awareness about and
protest against this issue -- all rely on the materials mined through this
process, and therefore are complicit in the problem. When raising these issues,
de Castro Leal et al. do not suggest abandoning technology altogether, instead
raising questions for computer scientists to consider when building projects and
conducting their research. Many of these questions encourage de-emphasizing
innovation in exchange for slower, more thoughtful creation and use of
technology \cite{de_castro_leal_into_2021}.

In considering these questions, I have primarily focused on creating an
imperfect but more sustainable than average software. It is useful to think
of my project not as the single final deliverable, but as many copies of it
distributed on a large scale, as that is what would likely do the most harm.
Extra peripherals are not required to avoid relying even more on unethically
produced materials. Any generic keyboard may be used to control the launcher.
Additionally, LÖVE is known to run on older hardware, avoiding the need to
buy any newer hardware \cite{noauthor_love_nodate}.
Despite these measures, I, along with most other computer scientists,
am complicit in this harmful process. No amount of consideration on an
individual level will solve these systemic issues of imperialist exploitation,
yet it is critical to attempt to address the ethics anyways, especially in
projects like this one.

%\section{Timeline}
%
%An initial idea for the timeline of my project is as follows:
%
%\begin{itemize}
%    \item June
%        \begin{itemize}
%            \item Begin prototyping hardware
%        \end{itemize}
%    \item July
%        \begin{itemize}
%            \item Obtain components for the hardware
%        \end{itemize}
%    \item August
%        \begin{itemize}
%            \item Week 1-2: Work on the modding APIs and solidify the intended
%                  game development process
%            \item Week 3-4: 3D print a case for the hardware components
%                  based on my prototype and begin constructing the hardware
%        \end{itemize}
%    \item September
%        \begin{itemize}
%            \item Week 1-2: Determine the most appropriate control scheme for
%                  the console and implement it
%            \item Week 3-4: Make the Linux environment that runs the game
%                  launcher and put it on the hardware
%        \end{itemize}
%    \item October
%        \begin{itemize}
%            \item Week 1-2: Work on a system to install games from USB media
%            \item Week 3-4: Finalize the documentation for the project, writing
%                  less technical tutorials in addition to refining all
%                  technical documentation
%        \end{itemize}
%    \item November
%        \begin{itemize}
%            \item Week 1-2: Evaluate the success of the project with more
%                  focused user testing
%            \item Week 3-4: Work on graphics, aesthetics and poster
%        \end{itemize}
%    \item December
%        \begin{itemize}
%            \item Week 1-2: Refine project, update poster if needed
%            \item Week 3-4: Last minute changes, submit the project
%        \end{itemize}
%\end{itemize}

\printbibliography

\appendix

\clearpage

\onecolumn

\end{document}
